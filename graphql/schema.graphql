"Adate String wz th tormat -d C.5. 2011-65-23"
scalar Date @scalar(class: "Nuwave\\Lighthouse\\Schema\\Types\\Scalars\\Date")

"A datetime string with format Y-m-d H:i:s', e.g. 2018-05-23 13:43:32."
scalar DateTime @scalar(class: "Nuwave\\Lighthouse\\Schema\\Types\\Scalars\\DateTime")

type User {
    id: ID!
    name: String!
    email: String!
    companies: [Company!]! @hasMany
    productsRated: [Product!]! @belongsToMany
    created_at: DateTime!
    updated_at: DateTime!
}

type Company {
    id: ID!
    name: String!
    user: User! @belongsTo
    productCount: Int! @count(relation: "products")
    products: [Product!]! @hasMany
    categories: [Category!]! @belongsToMany
    description: String
    created_at: DateTime!
    updated_at: DateTime!
}

type Product {
    id: ID!
    name: String!
    usersRated: [User!]! @belongsToMany
    hasRated: Int @method
    avg: Float @aggregate(relation: "usersRated", column: "product_ratings.rating", function: AVG)
    company: Company! @belongsTo
    description: String
    created_at: DateTime!
    updated_at: DateTime!
}

type Category {
    id: ID!
    name: String
    companies: [Company!]! @belongsToMany
    created_at: DateTime!
    updated_at: DateTime!
}

type ProductRating {
    id: ID!
    rating: Int!
    user: User! @belongsTo
    product: Product! @belongsTo
}

type Query {
    me: User @auth
    user(id: ID! @eq): User @find
    users: [User!]! @all
    company(id: ID! @eq): Company @find
    companies: [Company!]! @all
    product(id: ID! @eq): Product @find
    products: [Product!]! @all
    category(id: ID! @eq): Category @find
    categories: [Category!]! @all
}

type CreateOrUpdateProductRatingPayload {
    product: Product!
}

input CreateCompanyInput {
    name: String! @rules(apply: [  "required", "string", "unique:companies,name"])
    description: String
    categories: CreateCategoryBelongsToMany
}

input UpdateCompanyInput {
    id: ID!
    name: String! @rules(apply: [ "unique:companies,name"])
    description: String!
    categories: CreateCategoryBelongsToMany
}

input CreateCategoryBelongsToMany {
    sync: [ID!]
}

input CreateProductInput {
    name: String! @rules(apply: [ "required", "string"])
    description: String! @rules(apply: [ "required", "string"])
    company_id: ID! @rules(apply: [ "required", "exists:companies,id"])
}

input UpdateProductInput {
    id: ID!
    name: String!
    description: String
}

input UpdateCategoryInput {
    id: ID!
    name: String! @rules(apply: [ "unique:categories,name"])
}

input CreateOrUpdateProductRatingInput {
    product_id: ID! @rules(apply: [ "exists:products,id"])
    rating: String! @rules(apply: [  "required", "numeric", "min:1", "max:5"])
}

#import sanctum.graphql

type Mutation {
    createCompany(input: CreateCompanyInput! @spread): Company
    @create @guard @inject(context: "user.id", name: "user_id")
    updateCompany(input: UpdateCompanyInput! @spread): Company
    @update @guard @can(ability: "update", find: "id")
    deleteCompany(id: ID!): Company
    @delete @guard @can(ability: "delete", find: "id")
    createProduct(input: CreateProductInput! @spread): Product
    @create @guard @can(ability: "create", injectArgs: true)
    updateProduct(input: UpdateProductInput! @spread): Product
    @update @guard @can(ability: "update", find: "id")
    deleteProduct(id: ID!): Product
    @delete @guard @can(ability: "delete", find: "id")
    createCategory(name: String!): Category
    @create @guard
    updateCategory(input: UpdateCategoryInput! @spread): Category
    @update @guard
    deleteCategory(id: ID!): Category
    @delete @guard
    createOrUpdateProductRating(input: CreateOrUpdateProductRatingInput! @spread): CreateOrUpdateProductRatingPayload!
    @field(resolver: "App\\GraphQL\\Mutations\\CreateOrUpdateProductRatingPayload")
    deleteProductRating(id: ID!): CreateOrUpdateProductRatingPayload
    @delete @guard @can(ability: "delete", find: "id")
}

